
# 문제 URL : https://codeup.kr/problem.php?id=6098

"""
[문제]
영일이는 생명과학에 관심이 생겨 왕개미를 연구하고 있었다.

왕개미를 유심히 살펴보던 중 특별히 성실해 보이는 개미가 있었는데,
그 개미는 개미굴에서 나와 먹이까지 가장 빠른 길로 이동하는 것이었다.

개미는 오른쪽으로 움직이다가 벽을 만나면 아래쪽으로 움직여 가장 빠른 길로 움직였다.
(오른쪽에 길이 나타나면 다시 오른쪽으로 움직인다.)

이에 호기심이 생긴 영일이는 그 개미를 미로 상자에 넣고 살펴보기 시작하였다.

미로 상자에 넣은 개미는 먹이를 찾았거나, 더 이상 움직일 수 없을 때까지
오른쪽 또는 아래쪽으로만 움직였다.

미로 상자의 구조가 0(갈 수 있는 곳), 1(벽 또는 장애물)로 주어지고,
먹이가 2로 주어질 때, 성실한 개미의 이동 경로를 예상해보자.

단, 맨 아래의 가장 오른쪽에 도착한 경우, 더 이상 움직일 수 없는 경우, 먹이를 찾은 경우에는
더이상 이동하지 않고 그 곳에 머무른다고 가정한다.

미로 상자의 테두리는 모두 벽으로 되어 있으며,
개미집은 반드시 (2, 2)에 존재하기 때문에 개미는 (2, 2)에서 출발한다.

"""
# 미로상자 초기화
box = []

# 미로상자 모양 입력 처리
for _ in range(10):
    box.append(list(map(int, input().split())))

# 개미의 움직임을 구현하기 위해 BFS 알고리즘 이용
from collections import deque

# 개미가 움직이는 방향
dx = [0, 1]
dy = [1, 0]

# deque 선언
q = deque()

# 개미굴 위치 지정
# 리스트의 index 시작은 0이기 때문에 -1 처리
box[1][1] = 9
q.append((1, 1))
# 개미 이동방향 기록하는 로직 수행
while q:
    x, y = q.popleft()
    for i in range(2):
        nx = x + dx[i]; ny = y + dy[i]
        # 개미이동여부 확인 
        if (box[nx][ny] == 0):
            box[nx][ny] = 9
            q.append((nx, ny))
            break
        elif (box[nx][ny] == 2):
            # 먹이의 위치를 발견할 경우
            box[nx][ny] = 9
            q.clear()
            break

# 정답 출력
for i in range(10):
    for j in range(10):
        if j == 9:
            print(box[i][j])
        else:
            print(box[i][j], end=' ')
